# JS Framework APIs

There APIs is designed for JS Framework and Native Engine working together.

## Called from native and implemented by JS Framework

### `createInstance(instanceId, code, options, data)`

Create a Weex instance from Native Engine

* `instanceId`: The unique id for a Weex instance, generated by Native Engine.
* `code`: The JS bundle code send from Native Engine. It will be executed by `new Function(code)` in JS Framework. The code format depends on [JS Bundle Foramt](js-bundle-format.md)
* `options`: *Optional*. An options object. *Currently it supports `debug` flag which enable printing log and `bundleUrl` flag which the url of bundle.*
* `data`: *Optional*. It's an chance to supply external data instead of the original data in JS bundle.

Example:

```
createInstance('x', 'define(...); define(...); define(...); bootstrap(...)')
```

### `destroyInstance(instanceId)`

Destroy an existed Weex instance by id from Native Engine

### `refreshInstance(instanceId, data)`

Refresh data to an existed Weex instance with certain external data from Native Engine

Example:

```
refreshInstance('x', {a: 100, b: 200})
```

### `registerComponents(components)`

Register all native components

* `components`: A map that the keys are component types and the values are config of each type of component. *Currently it supports any attrubite of node by defualt. For example, the `append` which forces the appending way (`tree` or `node`) when first rendering, but will be overwritten by given the attribute on element in source code.*

Example:

```
registerComponents({
  container: {}, 
  text: {
    style: {
      color: 'red'
    }
  }, 
  image: {},
  slider: {append: 'tree'},
  list: {}, 
  cell: {append: 'tree'}, 
  ...
})
```

### `registerModules(modules)`

Register the name, methods and args format of each module

* `modules`: A map that collects all module definitions. Each module definition is a list which has several API definitions. And each API definition has a `name` string and a `args` array which contains a list of each parameter's type.

**NOTE: if the parameter's type is `node` or `function`, then it will automatically transfer to a string of `node reference` or `function id`**

Example:

```
registerModules({
  event: [
    {name: 'openURL', args: ['string']}
  ],
  ...
})
```

### `callJS(instanceId, tasks)`

Fire events or callbacks to an existed Weex instance from Native Engine

* `tasks[]`: A task list. Each task has a `method="fireEvent|callback"` property and a list of `args`.
    - In `fireEvent` method, the `args` is `ref` of the target, event `type` and event `data` in order.
    - In `callback` method, the `args` is `funcId` of a handler, `data` and `ifKeepAlive` which describes whether this callback handler should be keeping called. (Each callback handler is matched with a `funcId` when the original call happens.)

Example:

```
callJS('x', [{method: 'fireEvent', args: ['x', '13', 'click', {a: 100, b: 200}]}])
callJS('x', [{method: 'callback', args: ['x', '7', {a: 100, b: 200}, true]}])
```

### `getRoot(instanceId)`

Return a JSON object which describes the whole virtual DOM body of an existed Weex instance, which designed for debugging

Example:

```
getRoot('x')
// {ref: '_root', type: 'container', attr: {...}, style: {...}, children: [...]}
```

## Called from JavaScript and implemented with native code

### `callNative(instanceId, tasks)`

Make native calls from JS Framework

* `tasks[]`: A task list. Each task has a `module` name, a `method` name, and a `args[]` list.

Example:

```
callNative('x', [
  {module: 'dom', method: 'addElement', args: ['_root', {ref: '1', type: 'container'}, -1]},
  {module: 'dom', method: 'addElement', args: ['1', {ref: '2', type: 'text', ...}, -1]},
  {module: 'dom', method: 'addElement', args: ['1', {ref: '3', type: 'image', ...}, -1]},
  ...
])
```
